#!/usr/bin/env python3
"""Transform Insider Transactions data into analytical features.

Creates table ``transformed.insider_transactions_features`` containing insider trading
activity features such as insider buy/sell ratios, executive seniority analysis,
trading volume patterns, and sentiment indicators.
"""

from __future__ import annotations

import sys
from pathlib import Path
import re
from typing import Dict, Any

import numpy as np
import pandas as pd

sys.path.append(str(Path(__file__).parent.parent.parent))
from db.postgres_database_manager import PostgresDatabaseManager


class InsiderTransactionsTransformer:
    """Create analytical features from insider transactions information."""

    def __init__(self, universe_id: str | None = None) -> None:
        self.db = PostgresDatabaseManager()
        self.universe_id = universe_id
        self.rolling_window = 12  # Monthly aggregation over 12 months
        self.epsilon = 1e-6  # For safe division

# ------------------------- Patterns & Helpers -------------------------

# Tier patterns (order matters for clarity only; tier resolution uses MAX across matches)
TIER3_PATTERNS = [
    r"\bCEO\b",
    r"Chief\s+Executive\b",
    r"\bPresident\b",
    r"\bChair\b",
    r"Executive\s+Chair"
]

TIER2_PATTERNS = [
    r"\bCFO\b",
    r"\bCOO\b",
    r"\bEVP\b",
    r"\bSVP\b",
    r"Chief\s+\w+\s+Officer",   # any Chief <X> Officer (CIO, CMO, CHRO, etc.)
    r"Executive\s+Vice\s+President",
    r"Senior\s+Vice\s+President"
]

TIER1_PATTERNS = [
    r"\bDirector\b",
    r"Vice\s+President\b",      # non-exec VPs (if 'Executive Vice President' hit earlier â†’ tier 2)
    r"\bSecretary\b",
    r"\bTreasurer\b",
    r"Assistant\s+Secretary",
    r"Associate\s+VP"
]

OWNER_PATTERNS = [
    r"10%\s*Owner",
    r"Ten\s*Percent\s*Owner"
]

# For canonical role list (clean labels for modeling)
ROLE_LABELS = [
    ("CEO",           [r"\bCEO\b", r"Chief\s+Executive\b"]),
    ("President",     [r"\bPresident\b"]),
    ("Chair",         [r"\bChair\b", r"Executive\s+Chair"]),
    ("CFO",           [r"\bCFO\b", r"Chief\s+Financial\b"]),
    ("COO",           [r"\bCOO\b", r"Chief\s+Operating\b"]),
    ("EVP",           [r"\bEVP\b", r"Executive\s+Vice\s+President"]),
    ("SVP",           [r"\bSVP\b", r"Senior\s+Vice\s+President"]),
    ("Director",      [r"\bDirector\b"]),
    ("VP",            [r"Vice\s+President\b"]),
    ("Secretary",     [r"\bSecretary\b"]),
    ("Treasurer",     [r"\bTreasurer\b"]),
]

SEP_PATTERN = re.compile(r"\s*(,|/|&| and )\s*", flags=re.IGNORECASE)

def _regex_any(patterns: list[str], text: str) -> bool:
    return any(re.search(p, text, flags=re.IGNORECASE) for p in patterns)

def _find_roles(text: str) -> list[str]:
    roles: list[str] = []
    for label, patterns in ROLE_LABELS:
        if _regex_any(patterns, text):
            roles.append(label)
    # Ensure uniqueness and stable order from ROLE_LABELS
    seen = set()
    deduped = []
    for r in roles:
        if r not in seen:
            seen.add(r)
            deduped.append(r)
    return deduped

def _tier_from_text(text: str) -> int:
    tier = 0
    if _regex_any(TIER3_PATTERNS, text):
        tier = max(tier, 3)
    if _regex_any(TIER2_PATTERNS, text):
        tier = max(tier, 2)
    if _regex_any(TIER1_PATTERNS, text):
        tier = max(tier, 1)
    return tier

def _owner_flag(text: str) -> int:
    return 1 if _regex_any(OWNER_PATTERNS, text) else 0

def _flags(text: str, roles: list[str], owner: int) -> list[str]:
    flags = []
    if SEP_PATTERN.search(text):
        flags.append("multiple_roles")
    if re.search(r"\d+%|\bpercent\b", text, flags=re.IGNORECASE):
        flags.append("contains_percent")
    if owner == 1:
        flags.append("owner_detected")
    if not roles:
        flags.append("ambiguous")
    return sorted(set(flags))

def _clean_title(raw: str | None) -> str:
    if raw is None:
        return ""
    t = raw.strip()
    # Fix repeated spaces, normalize commas/ands etc. (light-touch; keep original for output)
    return re.sub(r"\s+", " ", t)

# ------------------------- Core Normalization -------------------------

def normalize_title(raw_title: str | None) -> dict[str, Any]:
    """
    Returns:
      {
        "executive_title_raw": <original>,
        "executive_title_clean": <cleaned>,
        "standardized_roles": ["CEO","Director",...],
        "seniority_tier": 0|1|2|3,
        "is_owner_10pct": 0|1,
        "flags": ["multiple_roles", ...]
      }
    """
    original = "" if raw_title is None else str(raw_title)
    clean = _clean_title(original)

    roles = _find_roles(clean)
    tier = _tier_from_text(clean)
    owner = _owner_flag(clean)
    flgs = _flags(clean, roles, owner)

    return {
        "executive_title_raw": original,
        "executive_title_clean": clean,
        "standardized_roles": roles,
        "seniority_tier": int(tier),
        "is_owner_10pct": int(owner),
        "flags": flgs
    }

# ------------------------- Database I/O -------------------------

def read_titles_from_database() -> list[dict[str, Any]]:
    """
    Reads executive_title data from the insider_transactions table.
    Creates an aggregate with title and count.
    Returns list of dicts: [{"title": "...", "count": <int>}]
    """
    db = PostgresDatabaseManager()
    db.connect()

    try:
        query = """
            SELECT executive_title, COUNT(*) as count
            FROM extracted.insider_transactions
            WHERE executive_title IS NOT NULL
                AND executive_title != ''
            GROUP BY executive_title
            ORDER BY count DESC
        """

        result = db.fetch_query(query)
        rows = []
        for row in result:
            rows.append({"title": row[0], "count": row[1]})

        return rows
    finally:
        db.close()

def read_titles_csv(path: str, title_col: str, count_col: str | None) -> list[dict[str, Any]]:
    """
    Reads a CSV with at least a title column. Count column is optional.
    Returns list of dicts: [{"title": "...", "count": <int or None>}]
    """
    rows = []
    with Path(path).open(newline="", encoding="utf-8-sig") as f:
        reader = csv.DictReader(f)
        # Try to auto-detect if not provided
        if title_col not in reader.fieldnames:
            # heuristics
            candidates = [c for c in reader.fieldnames if "title" in c.lower()]
            if not candidates:
                raise ValueError(f"Could not find title column. Available: {reader.fieldnames}")
            title_col = candidates[0]

        for r in reader:
            title = r.get(title_col, "")
            cnt = None
            if count_col:
                try:
                    cnt = int(r.get(count_col, "") or 0)
                except (ValueError, TypeError):
                    cnt = None
            rows.append({"title": title, "count": cnt})
    return rows

def write_mapping_csv(path: str, mapped: list[dict[str, Any]]) -> None:
    fields = [
        "executive_title_raw",
        "executive_title_clean",
        "standardized_roles_json",
        "seniority_tier",
        "is_owner_10pct",
        "flags_json",
        "count"
    ]
    with Path(path).open("w", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(f, fieldnames=fields)
        w.writeheader()
        for m in mapped:
            w.writerow({
                "executive_title_raw": m["executive_title_raw"],
                "executive_title_clean": m["executive_title_clean"],
                "standardized_roles_json": json.dumps(m["standardized_roles"], ensure_ascii=False),
                "seniority_tier": m["seniority_tier"],
                "is_owner_10pct": m["is_owner_10pct"],
                "flags_json": json.dumps(m["flags"], ensure_ascii=False),
                "count": m.get("count")
            })

# ------------------------- Public API (reusable) -------------------------

def map_titles_dataframe(df, title_col: str = "executive_title"):
    """
    If you're using pandas elsewhere, you can import this function and do:
        df = map_titles_dataframe(df, title_col="executive_title")
    It will add the following columns:
        - executive_title_clean
        - standardized_roles (list)
        - seniority_tier (int)
        - is_owner_10pct (int)
        - title_flags (list)
    """
    def _apply(title):
        out = normalize_title(title)
        return pd.Series({
            "executive_title_clean": out["executive_title_clean"],
            "standardized_roles": out["standardized_roles"],
            "seniority_tier": out["seniority_tier"],
            "is_owner_10pct": out["is_owner_10pct"],
            "title_flags": out["flags"]
        })
    return df.join(df[title_col].apply(_apply))

# ------------------------- Report Generation -------------------------

def generate_tier_report(output_path: str) -> None:
    """
    Generate CSV report with executive_title, tier_1_count, tier_2_count, tier_3_count, owner_count
    """
    # Read data from database
    titles_data = read_titles_from_database()

    report_data = []

    for title_info in titles_data:
        title = title_info["title"]
        count = title_info["count"]

        # Normalize the title to get tier and owner info
        normalized = normalize_title(title)
        tier = normalized["seniority_tier"]
        is_owner = normalized["is_owner_10pct"]

        # Create report row
        row = {
            "executive_title": title,
            "tier_1_count": count if tier == 1 else 0,
            "tier_2_count": count if tier == 2 else 0,
            "tier_3_count": count if tier == 3 else 0,
            "owner_count": count if is_owner == 1 else 0
        }
        report_data.append(row)

    # Write CSV report
    with Path(output_path).open('w', newline='', encoding='utf-8') as f:
        fieldnames = ['executive_title', 'tier_1_count', 'tier_2_count', 'tier_3_count', 'owner_count']
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerows(report_data)


    # Print summary statistics
    sum(row['tier_1_count'] for row in report_data)
    sum(row['tier_2_count'] for row in report_data)
    sum(row['tier_3_count'] for row in report_data)
    sum(row['owner_count'] for row in report_data)


# ------------------------- CLI -------------------------

def main():
    ap = argparse.ArgumentParser(description="Generate insider executive title tier report.")
    ap.add_argument("--output", default="./executive_title_tier_report.csv", help="Path to write tier report CSV (default: ./executive_title_tier_report.csv).")
    args = ap.parse_args()

    generate_tier_report(args.output)

if __name__ == "__main__":
    main()
